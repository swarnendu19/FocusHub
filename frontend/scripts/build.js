#!/usr/bin/env node

/**
 * Production Build Script
 * 
 * Optimized build process with additional checks and optimizations
 */

import { execSync } from 'child_process';
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const rootDir = join(__dirname, '..'); \n\n// Colors for console output\nconst colors = {\n  reset: '\\x1b[0m',\n  bright: '\\x1b[1m',\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  magenta: '\\x1b[35m',\n  cyan: '\\x1b[36m',\n};\n\nfunction log(message, color = 'reset') {\n  console.log(`${colors[color]}${message}${colors.reset}`);\n}\n\nfunction logStep(step) {\n  log(`\\nðŸ”§ ${step}`, 'cyan');\n}\n\nfunction logSuccess(message) {\n  log(`âœ… ${message}`, 'green');\n}\n\nfunction logError(message) {\n  log(`âŒ ${message}`, 'red');\n}\n\nfunction logWarning(message) {\n  log(`âš ï¸  ${message}`, 'yellow');\n}\n\nfunction runCommand(command, description) {\n  try {\n    log(`Running: ${command}`, 'blue');\n    execSync(command, { \n      cwd: rootDir, \n      stdio: 'inherit',\n      env: { ...process.env, NODE_ENV: 'production' }\n    });\n    logSuccess(description);\n  } catch (error) {\n    logError(`Failed: ${description}`);\n    process.exit(1);\n  }\n}\n\nfunction checkEnvironment() {\n  logStep('Checking environment variables');\n  \n  const requiredEnvVars = [\n    'VITE_API_URL',\n    'VITE_GOOGLE_CLIENT_ID'\n  ];\n  \n  const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n  \n  if (missingVars.length > 0) {\n    logWarning(`Missing environment variables: ${missingVars.join(', ')}`);\n    log('Make sure to set these in your .env.production file or CI/CD environment');\n  } else {\n    logSuccess('All required environment variables are set');\n  }\n}\n\nfunction generateBuildInfo() {\n  logStep('Generating build information');\n  \n  const buildInfo = {\n    version: process.env.npm_package_version || '1.0.0',\n    buildTime: new Date().toISOString(),\n    gitCommit: process.env.GITHUB_SHA || 'unknown',\n    gitBranch: process.env.GITHUB_REF_NAME || 'unknown',\n    nodeVersion: process.version,\n    environment: 'production'\n  };\n  \n  // Ensure dist directory exists\n  const distDir = join(rootDir, 'dist');\n  if (!existsSync(distDir)) {\n    mkdirSync(distDir, { recursive: true });\n  }\n  \n  writeFileSync(\n    join(distDir, 'build-info.json'),\n    JSON.stringify(buildInfo, null, 2)\n  );\n  \n  logSuccess('Build information generated');\n}\n\nfunction analyzeBundleSize() {\n  logStep('Analyzing bundle size');\n  \n  try {\n    runCommand('npm run build:analyze', 'Bundle analysis completed');\n  } catch (error) {\n    logWarning('Bundle analysis failed - continuing with build');\n  }\n}\n\nfunction runSecurityAudit() {\n  logStep('Running security audit');\n  \n  try {\n    runCommand('npm audit --audit-level=high --production', 'Security audit passed');\n  } catch (error) {\n    logWarning('Security audit found issues - please review');\n  }\n}\n\nfunction optimizeAssets() {\n  logStep('Optimizing assets');\n  \n  // Check if imagemin is available for image optimization\n  try {\n    runCommand('npx imagemin \"dist/**/*.{jpg,jpeg,png,gif,svg}\" --out-dir=dist', 'Images optimized');\n  } catch (error) {\n    logWarning('Image optimization skipped - imagemin not available');\n  }\n}\n\nfunction validateBuild() {\n  logStep('Validating build output');\n  \n  const distDir = join(rootDir, 'dist');\n  const indexPath = join(distDir, 'index.html');\n  \n  if (!existsSync(indexPath)) {\n    logError('Build validation failed: index.html not found');\n    process.exit(1);\n  }\n  \n  const indexContent = readFileSync(indexPath, 'utf-8');\n  \n  // Check for common issues\n  const checks = [\n    {\n      test: () => indexContent.includes('<script'),\n      message: 'JavaScript files are included'\n    },\n    {\n      test: () => indexContent.includes('<link') && indexContent.includes('stylesheet'),\n      message: 'CSS files are included'\n    },\n    {\n      test: () => !indexContent.includes('localhost'),\n      message: 'No localhost references found'\n    },\n    {\n      test: () => indexContent.includes('<meta name=\"viewport\"'),\n      message: 'Viewport meta tag is present'\n    }\n  ];\n  \n  let allChecksPassed = true;\n  \n  checks.forEach(check => {\n    if (check.test()) {\n      logSuccess(check.message);\n    } else {\n      logError(`Validation failed: ${check.message}`);\n      allChecksPassed = false;\n    }\n  });\n  \n  if (!allChecksPassed) {\n    logError('Build validation failed');\n    process.exit(1);\n  }\n  \n  logSuccess('Build validation passed');\n}\n\nfunction generateServiceWorkerManifest() {\n  logStep('Generating service worker manifest');\n  \n  try {\n    // This would typically use workbox-build or similar\n    // For now, we'll just copy the existing service worker\n    runCommand('cp public/service-worker.js dist/', 'Service worker copied');\n    logSuccess('Service worker manifest generated');\n  } catch (error) {\n    logWarning('Service worker generation failed');\n  }\n}\n\nfunction main() {\n  log('ðŸš€ Starting production build process', 'bright');\n  \n  try {\n    // Pre-build checks\n    checkEnvironment();\n    runSecurityAudit();\n    \n    // Clean previous build\n    logStep('Cleaning previous build');\n    runCommand('rm -rf dist', 'Previous build cleaned');\n    \n    // Type checking\n    logStep('Running type check');\n    runCommand('npm run type-check', 'Type checking completed');\n    \n    // Linting\n    logStep('Running linter');\n    runCommand('npm run lint', 'Linting completed');\n    \n    // Unit tests\n    logStep('Running unit tests');\n    runCommand('npm run test:ci', 'Unit tests passed');\n    \n    // Build the application\n    logStep('Building application');\n    runCommand('npm run build:vite', 'Application built successfully');\n    \n    // Post-build optimizations\n    generateBuildInfo();\n    optimizeAssets();\n    generateServiceWorkerManifest();\n    \n    // Validation\n    validateBuild();\n    \n    // Optional: Bundle analysis\n    if (process.env.ANALYZE_BUNDLE === 'true') {\n      analyzeBundleSize();\n    }\n    \n    log('\\nðŸŽ‰ Production build completed successfully!', 'green');\n    log('ðŸ“¦ Build output is in the dist/ directory', 'cyan');\n    \n  } catch (error) {\n    logError('Build process failed');\n    console.error(error);\n    process.exit(1);\n  }\n}\n\n// Run the build process\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main();\n}\n\nexport { main as buildProduction };